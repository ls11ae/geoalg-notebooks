from abc import ABC, abstractmethod
from itertools import chain
import time
from typing import Callable, Generic, Optional, TypeVar, Union

from ..geometry import AnimationObject, Line, LineSegment, Point, PointReference
from ..data_structures import DoublyConnectedSimplePolygon, DoublyConnectedEdgeList, PointLocation
from .drawing import DrawingMode
from .drawing_modes import LineSegmentsMode, LineMode, PointsMode, PolygonMode, DCELMode

import numpy as np


I = TypeVar("I")

Algorithm = Callable[[I], AnimationObject]
'''
General class to handle all instances of visualisation.

Holds an instance of type I (for example a set of points) that gets used as an input to whatever algorithm is called

'''
class InstanceHandle(ABC, Generic[I]):
    def __init__(self, instance: I, drawing_mode: DrawingMode, default_number_of_random_points : int):
        self._instance = instance
        self._drawing_mode = drawing_mode
        self._default_number_of_random_points = default_number_of_random_points

    @property
    def drawing_mode(self) -> DrawingMode:
        return self._drawing_mode

    '''
    runs the algorithm and returns its output aswell as the time it took to run
    '''
    def run_algorithm(self, algorithm: Algorithm[I]) -> tuple[AnimationObject, float]:
        instance_points = self.extract_points_from_raw_instance(self._instance)

        start_time = time.perf_counter()
        algorithm_output = algorithm(self._instance)
        end_time = time.perf_counter()

        self.clear()
        for point in instance_points:
            self.add_point(point)

        return algorithm_output, 1000 * (end_time - start_time)
    
    '''
    runs a preprocessing algorithm before the algorithm itself. Returns the algorithms solution and the time it took to run
    '''
    def run_algorithm_with_preprocessing(self, preprocessing: Algorithm[I], algorithm: Algorithm[I]) -> tuple[AnimationObject, float]:
        instance_points = self.extract_points_from_raw_instance(self._instance)

        preprocessing(self._instance)

        start_time = time.perf_counter()
        algorithm_output = algorithm(self._instance)
        end_time = time.perf_counter()

        self.clear()
        for point in instance_points:
            self.add_point(point)

        return algorithm_output, 1000 * (end_time - start_time)

    '''
    adds a single point to the instance

    why this return value?
    '''
    @abstractmethod
    def add_point(self, point: Point) -> Union[bool, tuple[bool, Point]]:
        pass

    '''
    clears the insance
    '''
    @abstractmethod
    def clear(self):
        pass

    '''
    returns the instance size
    '''
    @abstractmethod
    def size(self) -> int:
        pass

    '''
    creates either a list of points or pointreferences from the instance
    '''
    @staticmethod
    @abstractmethod
    def extract_points_from_raw_instance(instance: I) -> list[Point] | list[PointReference]:
        pass
    
    '''
    how many points should be generated by default to create an example. 
    '''
    @property
    def default_number_of_random_points(self) -> int:
        return self._default_number_of_random_points
    
    @default_number_of_random_points.setter
    def number_of_points(self, value):
        self._default_number_of_random_points = value

    def generate_random_points(self, max_x: float, max_y: float, number: int) -> list[Point]:
        x_values = np.random.uniform(0.05 * max_x, 0.95 * max_x, number)
        y_values = np.random.uniform(0.05 * max_y, 0.95 * max_y, number)
        return [Point(x, y) for x, y  in zip(x_values, y_values)]